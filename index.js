'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enable = exports.disable = undefined;

var _scrollmonitor = require('scrollmonitor');

var _scrollmonitor2 = _interopRequireDefault(_scrollmonitor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 2.3.2
// Deps
var addListeners, counter, directive, disabled, isNumeric, monitors, objIsSame, offset, removeListeners, update;

// A dictionary for storing data per-element
counter = 0;

monitors = {};

// Support toggling of global disabled state
disabled = false;

var disable = exports.disable = function disable() {
  return disabled = true;
};

var enable = exports.enable = function enable() {
  var id, monitor, results;
  disabled = false;
  results = [];
  for (id in monitors) {
    monitor = monitors[id];
    results.push(update(monitor));
  }
  return results;
};

// Create scrollMonitor after the element has been added to DOM
addListeners = function addListeners(el, binding) {
  var id, monitor, ref;

  // If an indvidual instance is disabled, just add the in viewport classes so
  // to reveal the element
  if (binding != null ? (ref = binding.value) != null ? ref.disabled : void 0 : void 0) {
    el.classList.add.apply(el.classList, ['in-viewport', 'fully-in-viewport']);
    return;
  }
  // Create and generate a unique id that will be store in a data value on
  // the element
  monitor = {
    el: el,
    modifiers: binding.modifiers,
    watcher: _scrollmonitor2.default.create(el, offset(binding.value))
  };
  id = 'i' + counter++;
  el.setAttribute('data-in-viewport', id);
  monitors[id] = monitor;
  // Start listenting for changes
  monitor.watcher.on('stateChange', function () {
    return update(monitor);
  });
  if (!disabled) {
    // Update intiial state, which also handles `once` prop
    return update(monitor);
  }
};

// Parse the binding value into scrollMonitor offsets
offset = function offset(value) {
  if (isNumeric(value)) {
    return {
      top: value,
      bottom: value
    };
  } else {
    return {
      top: (value != null ? value.top : void 0) || directive.defaults.top,
      bottom: (value != null ? value.bottom : void 0) || directive.defaults.bottom
    };
  }
};

// Test if var is a number
isNumeric = function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
};

// Update element classes based on current scrollMonitor state
update = function update(_ref) {
  var el = _ref.el,
      watcher = _ref.watcher,
      modifiers = _ref.modifiers;

  var add, remove, toggle;
  if (disabled) {
    return;
  }
  // Init vars
  add = []; // Classes to add
  remove = []; // Classes to remove

  // Util to DRY up population of add and remove arrays
  toggle = function toggle(bool, klass) {
    if (bool) {
      return add.push(klass);
    } else {
      return remove.push(klass);
    }
  };
  // Determine which classes to add
  toggle(watcher.isInViewport, 'in-viewport');
  toggle(watcher.isFullyInViewport, 'fully-in-viewport');
  toggle(watcher.isAboveViewport, 'above-viewport');
  toggle(watcher.isBelowViewport, 'below-viewport');
  if (add.length) {
    // Apply classes to element
    el.classList.add.apply(el.classList, add);
  }
  if (remove.length) {
    el.classList.remove.apply(el.classList, remove);
  }
  // If set to update "once", remove listeners if in viewport
  if (modifiers.once && !modifiers.fully && watcher.isInViewport || modifiers.once && modifiers.fully && watcher.isFullyInViewport) {
    return removeListeners(el);
  }
};

// Compare two objects.  Doing JSON.stringify to conpare as a quick way to
// deep compare objects
objIsSame = function objIsSame(obj1, obj2) {
  return JSON.stringify(obj1) === JSON.stringify(obj2);
};

// Remove scrollMonitor listeners
removeListeners = function removeListeners(el) {
  var id, monitor, ref;
  id = el.getAttribute('data-in-viewport');
  if (monitor = monitors[id]) {
    if ((ref = monitor.watcher) != null) {
      ref.destroy();
    }
    return delete monitors[id];
  }
};

// Mixin definition
exports.default = directive = {
  // Define overrideable defaults
  defaults: {
    top: 0,
    bottom: 0,
    disabled: false
  },
  // Init
  inserted: function inserted(el, binding) {
    return addListeners(el, binding);
  },
  // If the value changed, re-init scrollbar since scrollMonitor doesn't provide
  // an API to update the offsets.
  componentUpdated: function componentUpdated(el, binding) {
    if (objIsSame(binding.value, binding.oldValue)) {
      return;
    }
    removeListeners(el);
    return addListeners(el, binding);
  },
  // Cleanup
  unbind: function unbind(el) {
    return removeListeners(el);
  }
};